<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dictation Studio</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%23f2e5cf'/%3E%3Cpath d='M18 18h18c5 0 9 4 9 9v22H27c-5 0-9-4-9-9V18z' fill='%23c45a2e'/%3E%3Cpath d='M46 18H28c-4 0-8 3-8 8v22h18c4 0 8-3 8-8V18z' fill='%23e7c19a'/%3E%3Cpath d='M26 26h14' stroke='%23222018' stroke-width='3' stroke-linecap='round'/%3E%3Cpath d='M26 34h14' stroke='%23222018' stroke-width='3' stroke-linecap='round'/%3E%3C/svg%3E" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #f6f0e4;
      --panel: #fff8ee;
      --ink: #222018;
      --muted: #6f6a5e;
      --accent: #c45a2e;
      --accent-2: #1f6f5b;
      --shadow: 0 12px 30px rgba(35, 30, 20, 0.12);
      --radius: 18px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "M PLUS Rounded 1c", "Trebuchet MS", sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at top, #fdf7ef 0%, #f0e2cc 55%, #ead4b6 100%);
      min-height: 100vh;
    }

    header {
      padding: 32px 6vw 16px;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 24px;
      flex-wrap: wrap;
    }

    header h1 {
      margin: 0;
      font-family: "M PLUS Rounded 1c", "Trebuchet MS", sans-serif;
      font-size: clamp(28px, 4vw, 40px);
      letter-spacing: 0.02em;
    }

    header p {
      margin: 6px 0 0;
      color: var(--muted);
      max-width: 520px;
    }

    main {
      padding: 0 6vw 40px;
      display: grid;
      gap: 28px;
    }

    .tabs {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .tab-btn {
      border: 2px solid transparent;
      background: var(--panel);
      color: var(--ink);
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: transform 0.2s ease, border-color 0.2s ease;
    }

    .tab-btn.active {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .view {
      display: none;
      background: var(--panel);
      padding: 24px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      animation: fadeIn 0.5s ease;
    }

    .view.active {
      display: block;
    }

    .grid {
      display: grid;
      gap: 20px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .practice-grid {
      grid-template-columns: 1fr;
    }

    .register-grid {
      grid-template-columns: 1fr;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 8px;
    }

    .set-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
    }

    .set-controls select {
      flex: 1;
      min-width: 180px;
    }

    input[type="text"],
    textarea,
    select {
      width: 100%;
      border-radius: 12px;
      border: 1px solid #d9cbb0;
      padding: 12px;
      font-size: 15px;
      font-family: inherit;
      background: #fff;
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .btn {
      padding: 12px 18px;
      border: none;
      border-radius: 12px;
      background: var(--accent);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    .btn.secondary {
      background: var(--accent-2);
    }

    .btn.ghost {
      background: transparent;
      color: var(--accent);
      border: 1px solid var(--accent);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .panel {
      border-radius: 14px;
      padding: 16px;
      background: #fffdfa;
      border: 1px solid #e1d4b9;
    }

    .list {
      display: grid;
      gap: 12px;
    }

    .list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid #eadbc3;
      background: #fff;
    }

    .list-item small {
      color: var(--muted);
    }

    .category-options {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin: 10px 0 12px;
    }

    .category-option {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      font-weight: 600;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 6px 12px;
      background: #f2e5cf;
      font-size: 12px;
      color: #6b5a3f;
      font-weight: 600;
    }

    .meter {
      height: 8px;
      border-radius: 999px;
      background: #eadbc3;
      overflow: hidden;
    }

    .meter span {
      display: block;
      height: 100%;
      background: var(--accent-2);
      width: 0;
      transition: width 0.3s ease;
    }

    .result {
      display: grid;
      gap: 8px;
      font-size: 14px;
    }

    .result .good {
      color: var(--accent-2);
      font-weight: 600;
    }

    .result .warn {
      color: var(--accent);
      font-weight: 600;
    }

    #revealBox.good {
      color: var(--accent-2);
    }

    #revealBox.warn {
      color: var(--accent);
    }

    .overlay {
      background: rgba(250, 245, 236, 0.7);
      border-radius: 12px;
      padding: 12px;
      font-weight: 700;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 28px;
      transform: translate(-50%, 10px);
      background: #222018;
      color: #fff8ee;
      padding: 10px 16px;
      border-radius: 999px;
      font-size: 13px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      box-shadow: var(--shadow);
    }

    .toast.show {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 700px) {
      header {
        padding: 24px 6vw 8px;
      }

      .view {
        padding: 18px;
      }

      .btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Dictation Studio</h1>
    </div>
    <div class="tabs">
      <button class="tab-btn active" data-view="practice">Dictation</button>
      <button class="tab-btn" data-view="speaking">Speaking</button>
      <button class="tab-btn" data-view="register">Register</button>
      <button class="tab-btn" data-view="maintenance">Maintenance</button>
    </div>
  </header>

  <main>
    <section id="register" class="view">
      <div class="grid register-grid">
        <div class="panel">
          <h2>Sentence Sets</h2>
          <div class="set-controls">
            <select id="setSelectRegister" class="set-picker"></select>
            <button class="btn ghost" id="renameSetBtn">Rename</button>
          </div>
          <div class="set-controls">
            <button class="btn secondary" id="addSetBtn">New Set</button>
            <button class="btn ghost" id="deleteSetBtn">Delete Set</button>
            <button class="btn ghost" id="importSetBtn">Import TSV</button>
            <button class="btn ghost" id="exportSetBtn">Export TSV</button>
            <input type="file" id="importInput" accept=".tsv,text/tab-separated-values" style="display:none;" />
          </div>
        </div>

        <div class="panel">
          <h2>Add Sentence</h2>
          <input id="sentenceJp" type="text" placeholder="Enter a Japanese sentence" />
          <input id="sentenceEn" type="text" placeholder="Enter an English sentence" style="margin-top: 10px; margin-bottom: 8px;" />
          <label>Categories</label>
          <div class="category-options">
            <label class="category-option">
              <input type="checkbox" id="categoryDictation" checked />
              Dictation
            </label>
            <label class="category-option">
              <input type="checkbox" id="categorySpeaking" />
              Speaking
            </label>
          </div>

          <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));">
            <button class="btn" id="saveBtn">Save</button>
            <button class="btn ghost" id="clearBtn">Clear</button>
          </div>
        </div>

        <div class="panel">
          <h3>Saved Sentences</h3>
          <div style="margin-bottom: 10px;">
            <button class="btn ghost" id="orderBtn">Newest First</button>
            <button class="btn ghost" id="showActiveBtn">Active</button>
            <button class="btn ghost" id="showCorrectBtn">Tomorrow</button>
            <button class="btn ghost" id="showLearnedBtn">Week</button>
            <button class="btn ghost" id="showMonthBtn">Month</button>
            <button class="btn ghost" id="showArchivedBtn">Archived</button>
          </div>
          <div style="margin-bottom: 10px;">
            <button class="btn ghost" id="showAllCategoriesBtn">All Categories</button>
            <button class="btn ghost" id="showDictationBtn">Dictation</button>
            <button class="btn ghost" id="showSpeakingBtn">Speaking</button>
            <button class="btn ghost" id="showUncategorizedBtn">Uncategorized</button>
          </div>
          <div class="list" id="sentenceList"></div>
          <div style="margin-top: 20px;">
            <h4>History</h4>
            <input id="historySearch" type="text" placeholder="Search recent 100 prompts" style="margin: 8px 0 12px;" />
            <div class="list" id="historyList"></div>
          </div>
        </div>
      </div>
    </section>

    <section id="maintenance" class="view">
      <div class="grid register-grid">
        <div class="panel">
          <h2>Backup & Restore</h2>
          <p style="margin-bottom: 12px;">Export all sets as JSON, or restore them from a backup file.</p>
          <div class="set-controls">
            <button class="btn secondary" id="backupBtn">Backup JSON</button>
            <button class="btn ghost" id="restoreBtn">Restore JSON</button>
            <input type="file" id="restoreInput" accept=".json,application/json" style="display:none;" />
          </div>
        </div>
      </div>
    </section>

    <section id="practice" class="view active">
      <div class="grid practice-grid">
        <div class="panel">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 12px; flex-wrap: wrap;">
            <div class="chip" id="progressText"></div>
            <div style="flex: 1; min-width: 200px;">
              <select id="setSelectPractice" class="set-picker"></select>
            </div>
          </div>
          <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));">
            <button class="btn secondary" id="playBtn">Play</button>
          </div>

          <textarea id="answer" placeholder="Type here" style="margin-top: 10px;"></textarea>

          <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));">
            <button class="btn ghost" id="correctBtn" style="display:none;">Tomorrow</button>
            <button class="btn ghost" id="learnedBtn" style="display:none;">Week</button>
            <button class="btn ghost" id="monthBtn" style="display:none;">Month</button>
            <button class="btn ghost" id="archivedBtn" style="display:none;">Archived</button>
            <button class="btn" id="checkBtn">Check</button>
          </div>
        </div>

        <div class="panel">
          <h3>Results</h3>
          <div id="revealBox" class="overlay" style="display:none; margin: 8px 0 12px;"></div>
          <div class="result" id="resultBox"></div>
        </div>
      </div>
    </section>

    <section id="speaking" class="view">
      <div class="grid practice-grid">
        <div class="panel">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 12px; flex-wrap: wrap;">
            <div class="chip" id="speakingProgress"></div>
            <div style="flex: 1; min-width: 200px;">
              <select id="setSelectSpeaking" class="set-picker"></select>
            </div>
          </div>

          <div class="panel" style="margin-bottom: 12px;">
            <div id="speakingPrompt" style="font-size: 18px; font-weight: 600;"></div>
          </div>

          <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));">
            <button class="btn ghost" id="speakingCorrectBtn" style="display:none;">Tomorrow</button>
            <button class="btn ghost" id="speakingLearnedBtn" style="display:none;">Week</button>
            <button class="btn ghost" id="speakingMonthBtn" style="display:none;">Month</button>
            <button class="btn ghost" id="speakingArchivedBtn" style="display:none;">Archived</button>
            <button class="btn" id="speakingCheckBtn">Check</button>
          </div>
        </div>

        <div class="panel">
          <h3>Answer</h3>
          <div id="speakingReveal" class="overlay" style="display:none; margin: 8px 0 12px;"></div>
        </div>
      </div>
    </section>
  </main>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
    const storeKey = "dictation_sets_v1";
    const legacyStoreKey = "dictation_sentences_v1";
    const historyStoreKey = "dictation_history_v1";
    const historyMaxEntries = 100;
    const sentenceJpEl = document.getElementById("sentenceJp");
    const sentenceEnEl = document.getElementById("sentenceEn");
    const saveBtn = document.getElementById("saveBtn");
    const clearBtn = document.getElementById("clearBtn");
    const sentenceList = document.getElementById("sentenceList");
    const historySearch = document.getElementById("historySearch");
    const historyList = document.getElementById("historyList");
    const categoryDictationEl = document.getElementById("categoryDictation");
    const categorySpeakingEl = document.getElementById("categorySpeaking");
    const setSelects = document.querySelectorAll(".set-picker");
    const addSetBtn = document.getElementById("addSetBtn");
    const renameSetBtn = document.getElementById("renameSetBtn");
    const deleteSetBtn = document.getElementById("deleteSetBtn");
    const importSetBtn = document.getElementById("importSetBtn");
    const exportSetBtn = document.getElementById("exportSetBtn");
    const importInput = document.getElementById("importInput");
    const backupBtn = document.getElementById("backupBtn");
    const restoreBtn = document.getElementById("restoreBtn");
    const restoreInput = document.getElementById("restoreInput");

    const playBtn = document.getElementById("playBtn");
    const answerEl = document.getElementById("answer");
    const checkBtn = document.getElementById("checkBtn");
    const learnedBtn = document.getElementById("learnedBtn");
    const monthBtn = document.getElementById("monthBtn");
    const archivedBtn = document.getElementById("archivedBtn");
    const correctBtn = document.getElementById("correctBtn");
    const orderBtn = document.getElementById("orderBtn");
    const showActiveBtn = document.getElementById("showActiveBtn");
    const showLearnedBtn = document.getElementById("showLearnedBtn");
    const showMonthBtn = document.getElementById("showMonthBtn");
    const showArchivedBtn = document.getElementById("showArchivedBtn");
    const showCorrectBtn = document.getElementById("showCorrectBtn");
    const showAllCategoriesBtn = document.getElementById("showAllCategoriesBtn");
    const showDictationBtn = document.getElementById("showDictationBtn");
    const showSpeakingBtn = document.getElementById("showSpeakingBtn");
    const showUncategorizedBtn = document.getElementById("showUncategorizedBtn");
    const revealBox = document.getElementById("revealBox");
    const toast = document.getElementById("toast");
    const speakingPrompt = document.getElementById("speakingPrompt");
    const speakingReveal = document.getElementById("speakingReveal");
    const speakingCheckBtn = document.getElementById("speakingCheckBtn");
    const speakingCorrectBtn = document.getElementById("speakingCorrectBtn");
    const speakingLearnedBtn = document.getElementById("speakingLearnedBtn");
    const speakingMonthBtn = document.getElementById("speakingMonthBtn");
    const speakingArchivedBtn = document.getElementById("speakingArchivedBtn");
    const speakingProgress = document.getElementById("speakingProgress");

    const views = document.querySelectorAll(".view");
    const tabBtns = document.querySelectorAll(".tab-btn");

    const synth = window.speechSynthesis;
    const CATEGORY_DICTATION = "dictation";
    const CATEGORY_SPEAKING = "speaking";
    let utterance = null;
    let sets = [];
    let activeSetId = "";
    let sentences = [];
    let currentIndex = -1;
    let remainingIndices = [];
    let lastSentencesCount = 0;
    let sortNewestFirst = true;
    let speakingIndex = -1;
    let speakingRemainingIndices = [];
    let lastSpeakingCount = 0;
    let lastDueCount = 0;
    let lastSpeakingDueCount = 0;
    let editingIndex = -1;
    let historyLog = [];
    const learnedCooldownMs = 7 * 24 * 60 * 60 * 1000;
    const monthCooldownMs = 30 * 24 * 60 * 60 * 1000;
    const jstOffsetMs = 9 * 60 * 60 * 1000;
    let listFilter = "active";
    let categoryFilter = "all";
    
    function refreshActiveSetState() {
      updateSentencesReference();
      currentIndex = -1;
      remainingIndices = [];
      lastSentencesCount = sentences.length;
      lastDueCount = getDueIndicesByCategory(CATEGORY_DICTATION).length;
      speakingIndex = -1;
      speakingRemainingIndices = [];
      lastSpeakingCount = sentences.length;
      lastSpeakingDueCount = getDueIndicesByCategory(CATEGORY_SPEAKING).length;
      rebuildQueue();
      rebuildSpeakingQueue();
      resetPracticeUI();
      resetSpeakingUI();
      resetEditForm();
      renderAll();
    }

    function generateSetId() {
      if (window.crypto && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      return `set_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 7)}`;
    }

    function getDefaultSetName() {
      const used = new Set(sets.map((set) => set.name));
      let counter = sets.length + 1;
      let name = `Set ${counter}`;
      while (used.has(name)) {
        counter += 1;
        name = `Set ${counter}`;
      }
      return name;
    }

    function createSet(name, initialSentences = []) {
      return {
        id: generateSetId(),
        name: (name || "").trim() || getDefaultSetName(),
        sentences: [...initialSentences]
      };
    }

    function promptForSetName(defaultName) {
      const result = window.prompt("Enter set name", defaultName);
      if (result === null) return null;
      const trimmed = result.trim();
      return trimmed || defaultName;
    }

    function promptForSentenceText(label, currentValue) {
      const result = window.prompt(label, currentValue || "");
      if (result === null) return null;
      return result.trim();
    }

    function getActiveSet() {
      return sets.find((set) => set.id === activeSetId) || null;
    }

    function updateSentencesReference() {
      const active = getActiveSet();
      sentences = active ? active.sentences : [];
    }

    function getCooldownUntil(item) {
      if (!item) return 0;
      return Math.max(item.learnedUntil || 0, item.monthUntil || 0, item.correctUntil || 0);
    }

    function getNextJstMidnightTimestamp() {
      const now = Date.now();
      const nowJst = new Date(now + jstOffsetMs);
      const year = nowJst.getUTCFullYear();
      const month = nowJst.getUTCMonth();
      const date = nowJst.getUTCDate();
      return Date.UTC(year, month, date + 1, 0, 0, 0) - jstOffsetMs;
    }

    function isCooldownActive(timestamp) {
      if (!timestamp) return false;
      return Date.now() < timestamp;
    }

    function isSentenceDue(item) {
      if (!item) return false;
      if (item.archivedAt) return false;
      const cooldownUntil = getCooldownUntil(item);
      if (!cooldownUntil) return true;
      return Date.now() >= cooldownUntil;
    }

    function getSentenceCategories(item) {
      if (!item) return [CATEGORY_DICTATION];
      if (Array.isArray(item.categories) && item.categories.length > 0) {
        return item.categories;
      }
      return [CATEGORY_DICTATION];
    }

    function hasCategory(item, category) {
      return getSentenceCategories(item).includes(category);
    }

    function isUncategorized(item) {
      return !item || !Array.isArray(item.categories) || item.categories.length === 0;
    }

    function getDueIndicesByCategory(category) {
      return sentences
        .map((item, index) => ({ item, index }))
        .filter(({ item }) => isSentenceDue(item) && hasCategory(item, category))
        .map(({ index }) => index);
    }

    function hasCategorySentences(category) {
      return sentences.some((item) => hasCategory(item, category));
    }

    function saveSets() {
      const payload = { sets, activeSetId };
      localStorage.setItem(storeKey, JSON.stringify(payload));
    }

    function saveHistory() {
      localStorage.setItem(historyStoreKey, JSON.stringify(historyLog));
    }

    function isDuplicateEnglish(sentence, skipIndex = -1) {
      const target = normalizeText(sentence);
      if (!target) return false;
      return sentences.some((item, index) => {
        if (index === skipIndex) return false;
        return normalizeText(item.sentence || "") === target;
      });
    }

    function loadSets() {
      const raw = localStorage.getItem(storeKey);
      if (raw) {
        try {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            sets = parsed;
          } else if (parsed && Array.isArray(parsed.sets)) {
            sets = parsed.sets;
            activeSetId = parsed.activeSetId || "";
          }
        } catch (err) {
          sets = [];
          activeSetId = "";
        }
      }

      if (sets.length === 0) {
        const legacyRaw = localStorage.getItem(legacyStoreKey);
        if (legacyRaw) {
          try {
            const legacySentences = JSON.parse(legacyRaw);
            if (Array.isArray(legacySentences)) {
              const migrated = createSet("Set 1", legacySentences);
              sets = [migrated];
              activeSetId = migrated.id;
            }
          } catch (err) {
            sets = [];
            activeSetId = "";
          }
        }
      }

      if (sets.length === 0) {
        const fallback = createSet("Set 1");
        sets.push(fallback);
        activeSetId = fallback.id;
      }

      if (!activeSetId || !sets.some((set) => set.id === activeSetId)) {
        activeSetId = sets[0].id;
      }

      updateSentencesReference();
      lastSentencesCount = sentences.length;
      lastSpeakingCount = sentences.length;
      lastDueCount = getDueIndicesByCategory(CATEGORY_DICTATION).length;
      lastSpeakingDueCount = getDueIndicesByCategory(CATEGORY_SPEAKING).length;
      rebuildQueue();
      rebuildSpeakingQueue();
      saveSets();
    }

    function loadHistory() {
      const raw = localStorage.getItem(historyStoreKey);
      if (!raw) {
        historyLog = [];
        return;
      }
      try {
        const parsed = JSON.parse(raw);
        historyLog = Array.isArray(parsed) ? parsed.slice(0, historyMaxEntries) : [];
      } catch (err) {
        historyLog = [];
      }
    }

    function setActiveSet(id) {
      if (!id) return;
      const exists = sets.some((set) => set.id === id);
      if (!exists) return;
      activeSetId = id;
      refreshActiveSetState();
      saveSets();
    }

    function rebuildQueue() {
      remainingIndices = getDueIndicesByCategory(CATEGORY_DICTATION);
      if (remainingIndices.length > 1 && currentIndex >= 0) {
        remainingIndices = remainingIndices.filter((i) => i !== currentIndex);
      }
      for (let i = remainingIndices.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [remainingIndices[i], remainingIndices[j]] = [remainingIndices[j], remainingIndices[i]];
      }
    }

    function rebuildSpeakingQueue() {
      speakingRemainingIndices = getDueIndicesByCategory(CATEGORY_SPEAKING);
      if (speakingRemainingIndices.length > 1 && speakingIndex >= 0) {
        speakingRemainingIndices = speakingRemainingIndices.filter((i) => i !== speakingIndex);
      }
      for (let i = speakingRemainingIndices.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [speakingRemainingIndices[i], speakingRemainingIndices[j]] = [speakingRemainingIndices[j], speakingRemainingIndices[i]];
      }
    }

    function getPrimaryText(item) {
      return item.english || item.japanese || item.sentence || "";
    }

    function normalizeText(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s']/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function tokenize(text) {
      if (!text) return [];
      return normalizeText(text).split(" ").filter(Boolean);
    }

    function sanitizeTSVField(value) {
      if (value === null || value === undefined) return "";
      return String(value).replace(/\r?\n/g, " ").replace(/\t/g, " ").trim();
    }

    function buildTSVFromSentences(list) {
      if (!Array.isArray(list) || list.length === 0) return "";
      return list
        .map((item) => {
          const jp = sanitizeTSVField(item.jp || item.ja || "");
          const en = sanitizeTSVField(item.sentence || "");
          return `${jp}\t${en}`;
        })
        .join("\n");
    }

    function parseTSVContent(text) {
      if (!text) return [];
      const lines = text.split(/\r?\n/);
      const parsed = [];
      lines.forEach((rawLine) => {
        if (!rawLine) return;
        const line = rawLine.replace(/\r/g, "");
        const cleaned = line.replace(/^\uFEFF/, "").trim();
        if (!cleaned || cleaned.startsWith("#")) return;
        const firstTab = cleaned.indexOf("\t");
        if (firstTab === -1) return;
        const jp = cleaned.slice(0, firstTab).trim();
        const en = cleaned.slice(firstTab + 1).trim();
        if (!en) return;
        parsed.push({ jp, sentence: en, categories: [CATEGORY_DICTATION] });
      });
      return parsed;
    }

    function sanitizeFileName(name) {
      const base = (name || "set").trim() || "set";
      return base.replace(/[\\/:*?"<>|]/g, "_").slice(0, 60);
    }

    function exportCurrentSetToTSV() {
      const active = getActiveSet();
      if (!active) {
        alert("No active set selected.");
        return;
      }
      if (!active.sentences || active.sentences.length === 0) {
        alert("The current set has no sentences to export.");
        return;
      }
      const tsv = buildTSVFromSentences(active.sentences);
      if (!tsv) {
        alert("Unable to export empty data.");
        return;
      }
      const filename = `dictation_${sanitizeFileName(active.name || "set")}.tsv`;
      const blob = new Blob([tsv], { type: "text/tab-separated-values;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    function exportAllSetsToJSON() {
      if (!Array.isArray(sets) || sets.length === 0) {
        alert("No sets to back up.");
        return;
      }
      const payload = {
        version: 1,
        exportedAt: new Date().toISOString(),
        activeSetId,
        sets
      };
      const json = JSON.stringify(payload, null, 2);
      const filename = "dictation_backup.json";
      const blob = new Blob([json], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    function normalizeImportedSets(rawSets) {
      if (!Array.isArray(rawSets)) return [];
      return rawSets.map((set, index) => {
        const name = typeof set?.name === "string" && set.name.trim()
          ? set.name.trim()
          : `Set ${index + 1}`;
        const id = typeof set?.id === "string" && set.id.trim()
          ? set.id.trim()
          : generateSetId();
        const rawSentences = Array.isArray(set?.sentences) ? set.sentences : [];
        const sentences = rawSentences
          .map((item) => {
            if (!item || typeof item !== "object") return null;
            const sentence = typeof item.sentence === "string" ? item.sentence.trim() : "";
            if (!sentence) return null;
            const normalized = { ...item, sentence };
            if (typeof normalized.jp !== "string" && typeof normalized.ja === "string") {
              normalized.jp = normalized.ja;
            }
            return normalized;
          })
          .filter(Boolean);
        return { id, name, sentences };
      });
    }

    function importJSONContent(text) {
      let data = null;
      try {
        data = JSON.parse(text);
      } catch (err) {
        alert("Invalid JSON file.");
        return;
      }
      const normalized = normalizeImportedSets(data?.sets);
      if (normalized.length === 0) {
        alert("No valid sets were found in the JSON file.");
        return;
      }
      const confirmed = window.confirm(`Replace all current sets with ${normalized.length} imported sets?`);
      if (!confirmed) return;
      sets = normalized;
      activeSetId = typeof data?.activeSetId === "string"
        && sets.some((set) => set.id === data.activeSetId)
        ? data.activeSetId
        : sets[0].id;
      saveSets();
      refreshActiveSetState();
      showToast(`Restored ${sets.length} sets`);
    }

    function importTSVContent(text) {
      const active = getActiveSet();
      if (!active) {
        alert("No active set selected.");
        return;
      }
      const parsed = parseTSVContent(text);
      if (parsed.length === 0) {
        alert("No valid rows were found in the TSV file.");
        return;
      }
      const confirmed = window.confirm(`Replace all sentences in "${active.name}" with ${parsed.length} imported items?`);
      if (!confirmed) return;
      active.sentences = parsed;
      saveSets();
      refreshActiveSetState();
      showToast(`Imported ${parsed.length} sentences`);
    }

    function renderSetSelect() {
      if (!setSelects || setSelects.length === 0) return;
      setSelects.forEach((select) => {
        select.innerHTML = "";
        sets.forEach((set) => {
          const option = document.createElement("option");
          option.value = set.id;
          option.textContent = set.name || "Untitled Set";
          select.appendChild(option);
        });
        select.value = activeSetId;
      });
      if (renameSetBtn) {
        renameSetBtn.disabled = sets.length === 0;
      }
      if (deleteSetBtn) {
        deleteSetBtn.disabled = sets.length <= 1;
      }
    }

    function renderSentenceList() {
      sentenceList.innerHTML = "";
      updateLearnedFilterButtons();
      if (sentences.length === 0) {
        sentenceList.innerHTML = "<p>No sentences yet.</p>";
        return;
      }

      const formatPreview = (text) => {
        if (!text) return "-";
        return text.length > 48 ? `${text.slice(0, 48)}â€¦` : text;
      };
      const buildSentencePreview = (item) => {
        const jp = typeof item.jp === "string" ? item.jp.trim() : "";
        const en = typeof item.sentence === "string" ? item.sentence.trim() : "";
        const lines = [];
        if (jp) {
          lines.push(formatPreview(jp));
          if (en) {
            lines.push(formatPreview(en));
          }
        } else if (en) {
          lines.push(formatPreview(en));
        } else {
          lines.push("-");
        }
        return lines.map((line) => `<small>${line}</small>`).join("<br />");
      };
      const formatLearnedStatus = (item) => {
        if (!item || !item.learnedUntil) return "";
        const date = new Date(item.learnedUntil);
        if (Number.isNaN(date.getTime())) return "";
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      };
      const formatMonthStatus = (item) => {
        if (!item || !item.monthUntil) return "";
        const date = new Date(item.monthUntil);
        if (Number.isNaN(date.getTime())) return "";
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      };
      const formatCorrectStatus = (item) => {
        if (!item || !item.correctUntil) return "";
        const date = new Date(item.correctUntil);
        if (Number.isNaN(date.getTime())) return "";
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      };
      const formatArchivedStatus = (item) => {
        if (!item || !item.archivedAt) return "";
        const date = new Date(item.archivedAt);
        if (Number.isNaN(date.getTime())) return "";
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      };
      const formatCategoryChips = (item) => {
        if (isUncategorized(item)) {
          return `<span class="chip">Uncategorized</span>`;
        }
        const categories = getSentenceCategories(item);
        return categories.map((category) => {
          if (category === CATEGORY_SPEAKING) {
            return `<span class="chip">Speaking</span>`;
          }
          return `<span class="chip">Dictation</span>`;
        }).join("");
      };

      const indexed = sentences
        .map((item, index) => ({ item, index }))
        .filter(({ item }) => {
          const learnedActive = isCooldownActive(item.learnedUntil);
          const monthActive = isCooldownActive(item.monthUntil);
          const correctActive = isCooldownActive(item.correctUntil);
          const categoryMatch = categoryFilter === "all"
            || (categoryFilter === "uncategorized" ? isUncategorized(item) : hasCategory(item, categoryFilter));
          if (!categoryMatch) return false;
          if (listFilter === "learned") return learnedActive;
          if (listFilter === "month") return monthActive;
          if (listFilter === "correct") return correctActive;
          if (listFilter === "archived") return !!item.archivedAt;
          return !learnedActive && !monthActive && !correctActive && !item.archivedAt;
        });
      if (!sortNewestFirst) {
        indexed.reverse();
      }

      if (indexed.length === 0) {
        sentenceList.innerHTML = listFilter === "learned"
          ? "<p>No week sentences yet.</p>"
          : listFilter === "month"
            ? "<p>No month sentences yet.</p>"
          : listFilter === "correct"
            ? "<p>No tomorrow sentences yet.</p>"
          : listFilter === "archived"
            ? "<p>No archived sentences yet.</p>"
            : "<p>No active sentences.</p>";
        return;
      }

      indexed.forEach(({ item, index }) => {
        const learnedStatus = listFilter === "learned" ? formatLearnedStatus(item) : "";
        const monthStatus = listFilter === "month" ? formatMonthStatus(item) : "";
        const correctStatus = listFilter === "correct" ? formatCorrectStatus(item) : "";
        const archivedStatus = listFilter === "archived" ? formatArchivedStatus(item) : "";
        const showRestore = listFilter === "learned"
          || listFilter === "month"
          || listFilter === "correct"
          || listFilter === "archived";
        const row = document.createElement("div");
        row.className = "list-item";
        row.innerHTML = `
          <div class="sentence-text" data-sentence="${index}" style="cursor: pointer;" title="Double-click to copy">
            ${buildSentencePreview(item)}
          </div>
          <div>
            ${formatCategoryChips(item)}
            ${learnedStatus ? `<span class="chip">${learnedStatus}</span>` : ""}
            ${monthStatus ? `<span class="chip">${monthStatus}</span>` : ""}
            ${correctStatus ? `<span class="chip">${correctStatus}</span>` : ""}
            ${archivedStatus ? `<span class="chip">${archivedStatus}</span>` : ""}
            <button class="btn ghost" data-play-index="${index}">Play</button>
            <button class="btn ghost" data-edit-index="${index}">Edit</button>
            <button class="btn ghost" data-index="${index}">Delete</button>
            ${showRestore ? `<button class="btn ghost" data-restore-index="${index}">Restore</button>` : ""}
          </div>
        `;
        sentenceList.appendChild(row);
      });

      sentenceList.querySelectorAll(".sentence-text").forEach((el) => {
        el.addEventListener("dblclick", (e) => {
          const idx = Number(e.currentTarget.dataset.sentence);
          const item = sentences[idx];
          const jp = item && typeof item.jp === "string" ? item.jp.trim() : "";
          const en = item && typeof item.sentence === "string" ? item.sentence.trim() : "";
          const text = jp || en || "";
          if (text) {
            copyToClipboard(text);
          }
        });
      });

      sentenceList.querySelectorAll("button[data-index]").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const idx = Number(e.currentTarget.dataset.index);
          sentences.splice(idx, 1);
          saveSets();
          renderAll();
        });
      });

      sentenceList.querySelectorAll("button[data-play-index]").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const idx = Number(e.currentTarget.dataset.playIndex);
          const item = sentences[idx];
          const text = item ? (item.sentence || "") : "";
          if (!text) {
            showToast("No English sentence");
            return;
          }
          speakText(text, 1);
        });
      });

      sentenceList.querySelectorAll("button[data-edit-index]").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const idx = Number(e.currentTarget.dataset.editIndex);
          const item = sentences[idx];
          startEditingSentence(item, idx);
        });
      });

      sentenceList.querySelectorAll("button[data-restore-index]").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const idx = Number(e.currentTarget.dataset.restoreIndex);
          const item = sentences[idx];
          if (!item) return;
          if (item.learnedUntil) {
            delete item.learnedUntil;
          }
          if (item.monthUntil) {
            delete item.monthUntil;
          }
          if (item.correctUntil) {
            delete item.correctUntil;
          }
          if (item.archivedAt) {
            delete item.archivedAt;
          }
          saveSets();
          renderAll();
        });
      });
    }

    function formatHistoryTimestamp(timestamp) {
      if (!timestamp) return "-";
      const date = new Date(timestamp);
      if (Number.isNaN(date.getTime())) return "-";
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      const hh = String(date.getHours()).padStart(2, "0");
      const mm = String(date.getMinutes()).padStart(2, "0");
      return `${y}-${m}-${d} ${hh}:${mm}`;
    }

    function renderHistoryList() {
      if (!historyList) return;
      historyList.innerHTML = "";
      if (!historyLog || historyLog.length === 0) {
        historyList.innerHTML = "<p>No history yet.</p>";
        return;
      }
      const query = historySearch ? historySearch.value.trim().toLowerCase() : "";
      const filtered = query
        ? historyLog.filter((entry) => {
            const jp = (entry.jp || "").toLowerCase();
            const en = (entry.sentence || "").toLowerCase();
            const setName = (entry.setName || "").toLowerCase();
            return jp.includes(query) || en.includes(query) || setName.includes(query);
          })
        : historyLog;

      if (filtered.length === 0) {
        historyList.innerHTML = "<p>No history matches.</p>";
        return;
      }

      filtered.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "list-item";
        row.innerHTML = `
          <div>
            <small>${entry.jp ? entry.jp : "-"}</small><br />
            <small>${entry.sentence ? entry.sentence : "-"}</small>
          </div>
          <div>
            <span class="chip">${entry.setName || "Unknown Set"}</span>
            <span class="chip">${entry.category === CATEGORY_SPEAKING ? "Speaking" : "Dictation"}</span>
            <span class="chip">${formatHistoryTimestamp(entry.timestamp)}</span>
            <button class="btn ghost" data-history-action="play" data-history-id="${entry.id}">Play</button>
            <button class="btn ghost" data-history-action="edit" data-history-id="${entry.id}">Edit</button>
            <button class="btn ghost" data-history-action="delete" data-history-id="${entry.id}">Delete</button>
          </div>
        `;
        historyList.appendChild(row);
      });

      historyList.querySelectorAll("button[data-history-action]").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const action = e.currentTarget.dataset.historyAction;
          const entryId = e.currentTarget.dataset.historyId;
          const entry = historyLog.find((item) => item.id === entryId);
          if (!entry) return;
          if (action === "play") {
            const target = findHistoryTarget(entry);
            const text = target?.item?.sentence || entry.sentence || "";
            if (!text) {
              showToast("No English sentence");
              return;
            }
            speakText(text, 1);
            return;
          }
          if (action === "edit") {
            const target = findHistoryTarget(entry);
            if (!target || target.index < 0) {
              showToast("Sentence not found in set.");
              return;
            }
            if (target.set.id !== activeSetId) {
              setActiveSet(target.set.id);
            }
            const activeTarget = findHistoryTarget(entry);
            if (!activeTarget || activeTarget.index < 0) {
              showToast("Sentence not found in set.");
              return;
            }
            startEditingSentence(activeTarget.item, activeTarget.index);
            return;
          }
          if (action === "delete") {
            const target = findHistoryTarget(entry);
            if (!target || target.index < 0) {
              showToast("Sentence not found in set.");
              return;
            }
            const name = target.set.name || "Untitled Set";
            const confirmed = window.confirm(`Delete sentence from "${name}"?`);
            if (!confirmed) return;
            target.set.sentences.splice(target.index, 1);
            saveSets();
            if (target.set.id === activeSetId) {
              refreshActiveSetState();
            } else {
              renderHistoryList();
            }
          }
        });
      });
    }

    function updateLearnedFilterButtons() {
      if (showActiveBtn) {
        showActiveBtn.disabled = listFilter === "active";
      }
      if (showLearnedBtn) {
        showLearnedBtn.disabled = listFilter === "learned";
      }
      if (showMonthBtn) {
        showMonthBtn.disabled = listFilter === "month";
      }
      if (showArchivedBtn) {
        showArchivedBtn.disabled = listFilter === "archived";
      }
      if (showCorrectBtn) {
        showCorrectBtn.disabled = listFilter === "correct";
      }
      if (showAllCategoriesBtn) {
        showAllCategoriesBtn.disabled = categoryFilter === "all";
      }
      if (showDictationBtn) {
        showDictationBtn.disabled = categoryFilter === CATEGORY_DICTATION;
      }
      if (showSpeakingBtn) {
        showSpeakingBtn.disabled = categoryFilter === CATEGORY_SPEAKING;
      }
      if (showUncategorizedBtn) {
        showUncategorizedBtn.disabled = categoryFilter === "uncategorized";
      }
    }

    function copyToClipboard(text) {
      if (!text) return;
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => {
          showToast("Copied to clipboard");
        }).catch(() => {
          fallbackCopy(text);
        });
      } else {
        fallbackCopy(text);
      }
    }

    function renderPracticeSelect() {
      const dueCount = getDueIndicesByCategory(CATEGORY_DICTATION).length;
      if (!hasCategorySentences(CATEGORY_DICTATION)) {
        playBtn.disabled = true;
        checkBtn.disabled = true;
        learnedBtn.disabled = true;
        monthBtn.disabled = true;
        archivedBtn.disabled = true;
        resetPracticeUI();
        revealBox.style.display = "block";
        revealBox.className = "overlay";
        revealBox.textContent = "No dictation sentences yet.";
        answerEl.disabled = true;
        updateProgress();
        return;
      }
      if (sentences.length === 0) {
        playBtn.disabled = true;
        checkBtn.disabled = true;
        learnedBtn.disabled = true;
        monthBtn.disabled = true;
        archivedBtn.disabled = true;
        resetPracticeUI();
        updateProgress();
        return;
      }
      if (dueCount === 0) {
        playBtn.disabled = true;
        checkBtn.disabled = true;
        learnedBtn.disabled = true;
        monthBtn.disabled = true;
        archivedBtn.disabled = true;
        showCompletedUI(true);
        return;
      }

      if (sentences.length !== lastSentencesCount) {
        rebuildQueue();
        lastSentencesCount = sentences.length;
      }
      if (dueCount !== lastDueCount) {
        rebuildQueue();
        rebuildSpeakingQueue();
        lastDueCount = dueCount;
      }
      playBtn.disabled = false;
      checkBtn.disabled = false;
      learnedBtn.disabled = false;
      monthBtn.disabled = false;
      pickRandomSentence();
      playBtn.focus();
    }

    function renderSpeakingSelect() {
      if (!speakingCheckBtn) return;
      const dueCount = getDueIndicesByCategory(CATEGORY_SPEAKING).length;
      if (!hasCategorySentences(CATEGORY_SPEAKING)) {
        speakingCheckBtn.disabled = true;
        resetSpeakingUI();
        updateSpeakingProgress();
        if (speakingPrompt) {
          speakingPrompt.textContent = "No speaking sentences yet.";
        }
        return;
      }
      if (sentences.length === 0) {
        speakingCheckBtn.disabled = true;
        resetSpeakingUI();
        updateSpeakingProgress();
        if (speakingPrompt) {
          speakingPrompt.textContent = "No sentences yet.";
        }
        return;
      }
      if (dueCount === 0) {
        speakingCheckBtn.disabled = true;
        showSpeakingCompletedUI(true);
        return;
      }
      if (sentences.length !== lastSpeakingCount) {
        rebuildSpeakingQueue();
        lastSpeakingCount = sentences.length;
      }
      if (dueCount !== lastSpeakingDueCount) {
        rebuildQueue();
        rebuildSpeakingQueue();
        lastSpeakingDueCount = dueCount;
      }
      speakingCheckBtn.disabled = false;
      pickSpeakingSentence();
    }

    function getSelectedSentence() {
      if (sentences.length === 0) return null;
      return sentences[currentIndex] || null;
    }

    function resetPracticeUI() {
      revealBox.style.display = "none";
      revealBox.className = "overlay";
      answerEl.value = "";
      answerEl.disabled = false;
      checkBtn.textContent = "Check";
      checkBtn.dataset.mode = "check";
      learnedBtn.style.display = "none";
      monthBtn.style.display = "none";
      archivedBtn.style.display = "none";
      correctBtn.style.display = "none";
    }

    function resetSpeakingUI() {
      if (!speakingReveal || !speakingCheckBtn || !speakingPrompt) return;
      speakingReveal.style.display = "none";
      speakingReveal.className = "overlay";
      speakingCheckBtn.textContent = "Check";
      speakingCheckBtn.dataset.mode = "check";
      if (speakingCorrectBtn) {
        speakingCorrectBtn.style.display = "none";
      }
      if (speakingLearnedBtn) {
        speakingLearnedBtn.style.display = "none";
      }
      if (speakingMonthBtn) {
        speakingMonthBtn.style.display = "none";
      }
      if (speakingArchivedBtn) {
        speakingArchivedBtn.style.display = "none";
      }
      speakingPrompt.textContent = "";
    }

    function startEditingSentence(item, index) {
      if (!item) return;
      editingIndex = index;
      sentenceJpEl.value = item.jp || "";
      sentenceEnEl.value = item.sentence || "";
      const categories = getSentenceCategories(item);
      if (categoryDictationEl) {
        categoryDictationEl.checked = categories.includes(CATEGORY_DICTATION);
      }
      if (categorySpeakingEl) {
        categorySpeakingEl.checked = categories.includes(CATEGORY_SPEAKING);
      }
      saveBtn.textContent = "Update";
      sentenceEnEl.focus();
    }

    function findHistoryTarget(entry) {
      if (!entry) return null;
      const set = sets.find((item) => item.id === entry.setId)
        || sets.find((item) => item.name === entry.setName);
      if (!set) return null;
      const targetSentence = (entry.sentence || "").trim();
      const targetJp = (entry.jp || "").trim();
      const normalizedSentence = normalizeText(targetSentence);
      let index = -1;
      if (targetSentence) {
        index = set.sentences.findIndex((item) => {
          const itemSentence = normalizeText(item.sentence || "");
          if (!itemSentence || itemSentence !== normalizedSentence) return false;
          if (targetJp) {
            const itemJp = (item.jp || "").trim();
            if (itemJp !== targetJp) return false;
          }
          return true;
        });
      }
      if (index < 0 && targetJp) {
        index = set.sentences.findIndex((item) => (item.jp || "").trim() === targetJp);
      }
      if (index < 0) return { set, index: -1, item: null };
      return { set, index, item: set.sentences[index] };
    }

    function logHistory(item, category) {
      if (!item) return;
      const active = getActiveSet();
      historyLog.unshift({
        id: `history_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 7)}`,
        timestamp: Date.now(),
        setId: active ? active.id : "",
        setName: active ? active.name : "",
        category,
        sentence: item.sentence || "",
        jp: item.jp || ""
      });
      if (historyLog.length > historyMaxEntries) {
        historyLog.length = historyMaxEntries;
      }
      saveHistory();
      renderHistoryList();
    }

    function pickRandomSentence() {
      if (sentences.length === 0) {
        currentIndex = -1;
        resetPracticeUI();
        return;
      }
      if (remainingIndices.length === 0) {
        // ä¸€å·¡å®Œäº†
        currentIndex = -1;
        showCompletedUI();
        return;
      }
      currentIndex = remainingIndices.shift();
      resetPracticeUI();
      updateProgress();
      playBtn.focus();
      logHistory(sentences[currentIndex], CATEGORY_DICTATION);
    }

    function pickSpeakingSentence() {
      if (!speakingPrompt) return;
      if (sentences.length === 0) {
        speakingIndex = -1;
        resetSpeakingUI();
        updateSpeakingProgress();
        speakingPrompt.textContent = "No sentences yet.";
        return;
      }
      if (speakingRemainingIndices.length === 0) {
        speakingIndex = -1;
        showSpeakingCompletedUI();
        return;
      }
      speakingIndex = speakingRemainingIndices.shift();
      const item = sentences[speakingIndex];
      resetSpeakingUI();
      speakingPrompt.textContent = item?.jp || item?.sentence || "";
      updateSpeakingProgress();
      logHistory(item, CATEGORY_SPEAKING);
    }

    function showCompletedUI(isDeferred = false) {
      revealBox.style.display = "block";
      revealBox.className = "overlay good";
      revealBox.textContent = isDeferred
        ? "âœ… No sentences due right now. Come back later!"
        : "ðŸŽ‰ All sentences completed!";
      answerEl.value = "";
      answerEl.disabled = true;
      playBtn.disabled = true;
      checkBtn.textContent = "Restart";
      checkBtn.dataset.mode = "restart";
      learnedBtn.style.display = "none";
      monthBtn.style.display = "none";
      correctBtn.style.display = "none";
      updateProgress();
    }

    function showSpeakingCompletedUI(isDeferred = false) {
      if (!speakingReveal || !speakingCheckBtn || !speakingPrompt) return;
      speakingPrompt.textContent = "";
      speakingReveal.style.display = "block";
      speakingReveal.className = "overlay good";
      speakingReveal.textContent = isDeferred
        ? "âœ… No sentences due right now. Come back later!"
        : "ðŸŽ‰ All sentences completed!";
      speakingCheckBtn.textContent = "Restart";
      speakingCheckBtn.dataset.mode = "restart";
      updateSpeakingProgress();
    }

    function updateProgress() {
      const total = getDueIndicesByCategory(CATEGORY_DICTATION).length;
      const done = total - remainingIndices.length - (currentIndex >= 0 ? 1 : 0);
      const progressEl = document.getElementById("progressText");
      if (progressEl) {
        if (total === 0) {
          progressEl.textContent = "0 due";
        } else if (currentIndex < 0 && remainingIndices.length === 0) {
          progressEl.textContent = `${total} / ${total} completed`;
        } else {
          progressEl.textContent = `${done + 1} / ${total}`;
        }
      }
    }

    function updateSpeakingProgress() {
      if (!speakingProgress) return;
      const total = getDueIndicesByCategory(CATEGORY_SPEAKING).length;
      const done = total - speakingRemainingIndices.length - (speakingIndex >= 0 ? 1 : 0);
      if (total === 0) {
        speakingProgress.textContent = "0 due";
      } else if (speakingIndex < 0 && speakingRemainingIndices.length === 0) {
        speakingProgress.textContent = `${total} / ${total} completed`;
      } else {
        speakingProgress.textContent = `${done + 1} / ${total}`;
      }
    }

    function getChromeEnglishVoice() {
      if (!synth) return null;
      const voices = synth.getVoices();
      if (!voices || voices.length === 0) return null;
      const googleUS = voices.find((voice) => voice.name === "Google US English");
      if (googleUS) return googleUS;
      const googleUK = voices.find((voice) => voice.name === "Google UK English Female");
      if (googleUK) return googleUK;
      const enUS = voices.find((voice) => (voice.lang || "").toLowerCase().startsWith("en-us"));
      if (enUS) return enUS;
      const en = voices.find((voice) => (voice.lang || "").toLowerCase().startsWith("en"));
      return en || null;
    }

    function applyChromeEnglishVoice(utter) {
      if (!utter) return;
      const voice = getChromeEnglishVoice();
      if (voice) {
        utter.voice = voice;
      }
    }

    function speakSentence(rate = 1) {
      const item = getSelectedSentence();
      if (!item) return;
      if (synth.speaking) {
        synth.cancel();
      }
      let count = 0;
      const speakOnce = () => {
        utterance = new SpeechSynthesisUtterance(item.sentence);
        utterance.rate = rate;
        utterance.lang = "en-US";
        applyChromeEnglishVoice(utterance);
        utterance.onend = () => {
          count += 1;
          if (count < 3) {
            setTimeout(speakOnce, 3000);
          }
        };
        synth.speak(utterance);
      };
      speakOnce();
    }

    function speakSentenceOnce(rate = 1) {
      const item = getSelectedSentence();
      if (!item) return;
      if (synth.speaking) {
        synth.cancel();
      }
      utterance = new SpeechSynthesisUtterance(item.sentence);
      utterance.rate = rate;
      utterance.lang = "en-US";
      applyChromeEnglishVoice(utterance);
      synth.speak(utterance);
    }

    function speakText(text, rate = 1) {
      if (!text) return;
      if (synth.speaking) {
        synth.cancel();
      }
      utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = rate;
      utterance.lang = "en-US";
      applyChromeEnglishVoice(utterance);
      synth.speak(utterance);
    }

    function speakSpeakingSentence(rate = 1) {
      const item = sentences[speakingIndex];
      const text = item ? (item.sentence || "") : "";
      if (!text) return;
      speakText(text, rate);
    }

    let toastTimer = null;

    function showToast(message) {
      if (!toast) return;
      toast.textContent = message;
      toast.classList.add("show");
      if (toastTimer) {
        clearTimeout(toastTimer);
      }
      toastTimer = setTimeout(() => {
        toast.classList.remove("show");
      }, 1600);
    }

    function resetEditForm() {
      editingIndex = -1;
      saveBtn.textContent = "Save";
      sentenceJpEl.value = "";
      sentenceEnEl.value = "";
      if (categoryDictationEl) {
        categoryDictationEl.checked = true;
      }
      if (categorySpeakingEl) {
        categorySpeakingEl.checked = false;
      }
    }

    function copyRevealToClipboard() {
      const text = revealBox.textContent.trim();
      if (!text) return false;
      const done = () => showToast("Copied to clipboard");
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(done).catch(() => {
          fallbackCopy(text);
        });
        return true;
      }
      fallbackCopy(text);
      return true;
    }

    function fallbackCopy(text) {
      const helper = document.createElement("textarea");
      helper.value = text;
      helper.setAttribute("readonly", "");
      helper.style.position = "absolute";
      helper.style.left = "-9999px";
      document.body.appendChild(helper);
      helper.select();
      try {
        document.execCommand("copy");
        showToast("Copied to clipboard");
      } catch (err) {
        showToast("Copy failed");
      }
      document.body.removeChild(helper);
    }

    function checkAnswer() {
      const item = getSelectedSentence();
      if (!item) return;
      const targetTokens = tokenize(item.sentence);
      const answerTokens = tokenize(answerEl.value);

      const targetSet = new Set(targetTokens);
      const answerSet = new Set(answerTokens);

      const matches = targetTokens.filter((w) => answerSet.has(w));
      const missing = targetTokens.filter((w) => !answerSet.has(w));

      const score = targetTokens.length === 0
        ? 0
        : Math.round((matches.length / targetTokens.length) * 100);

      const isCorrect = normalizeText(answerEl.value) === normalizeText(item.sentence);
      revealBox.className = isCorrect ? "overlay good" : "overlay warn";

      checkBtn.textContent = "Next";
      checkBtn.dataset.mode = "next";
      learnedBtn.style.display = "inline-flex";
      monthBtn.style.display = "inline-flex";
      archivedBtn.style.display = "inline-flex";
      correctBtn.style.display = "inline-flex";
      revealBox.style.display = "block";
      revealBox.textContent = item.sentence;
      copyRevealToClipboard();
      speakSentenceOnce(1);
    }

    function renderAll() {
      renderSetSelect();
      renderSentenceList();
      renderPracticeSelect();
      renderSpeakingSelect();
      renderHistoryList();
    }

    saveBtn.addEventListener("click", () => {
      const jp = sentenceJpEl.value.trim();
      const sentence = sentenceEnEl.value.trim();
      if (!sentence) {
        return;
      }
      if (isDuplicateEnglish(sentence, editingIndex)) {
        showToast("This English sentence is already registered.");
        return;
      }
      const categories = [];
      if (categoryDictationEl && categoryDictationEl.checked) {
        categories.push(CATEGORY_DICTATION);
      }
      if (categorySpeakingEl && categorySpeakingEl.checked) {
        categories.push(CATEGORY_SPEAKING);
      }
      if (categories.length === 0) {
        showToast("Select at least one category.");
        return;
      }
      if (editingIndex >= 0) {
        const item = sentences[editingIndex];
        if (!item) return;
        item.jp = jp;
        item.sentence = sentence;
        item.categories = categories;
      } else {
        const newItem = {
          sentence,
          jp,
          categories
        };
        sentences.unshift(newItem);
      }
      saveSets();
      resetEditForm();
      renderAll();
    });

    sentenceEnEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        saveBtn.click();
      }
    });

    clearBtn.addEventListener("click", () => {
      resetEditForm();
    });

    orderBtn.addEventListener("click", () => {
      sortNewestFirst = !sortNewestFirst;
      orderBtn.textContent = sortNewestFirst ? "Newest First" : "Oldest First";
      renderSentenceList();
    });

    if (showActiveBtn) {
      showActiveBtn.addEventListener("click", () => {
        listFilter = "active";
        renderSentenceList();
      });
    }

    if (showLearnedBtn) {
      showLearnedBtn.addEventListener("click", () => {
        listFilter = "learned";
        renderSentenceList();
      });
    }
    if (showMonthBtn) {
      showMonthBtn.addEventListener("click", () => {
        listFilter = "month";
        renderSentenceList();
      });
    }

    if (showArchivedBtn) {
      showArchivedBtn.addEventListener("click", () => {
        listFilter = "archived";
        renderSentenceList();
      });
    }
    if (showCorrectBtn) {
      showCorrectBtn.addEventListener("click", () => {
        listFilter = "correct";
        renderSentenceList();
      });
    }
    if (showAllCategoriesBtn) {
      showAllCategoriesBtn.addEventListener("click", () => {
        categoryFilter = "all";
        renderSentenceList();
      });
    }
    if (showDictationBtn) {
      showDictationBtn.addEventListener("click", () => {
        categoryFilter = CATEGORY_DICTATION;
        renderSentenceList();
      });
    }
    if (showSpeakingBtn) {
      showSpeakingBtn.addEventListener("click", () => {
        categoryFilter = CATEGORY_SPEAKING;
        renderSentenceList();
      });
    }
    if (showUncategorizedBtn) {
      showUncategorizedBtn.addEventListener("click", () => {
        categoryFilter = "uncategorized";
        renderSentenceList();
      });
    }

    if (setSelects && setSelects.length > 0) {
      setSelects.forEach((select) => {
        select.addEventListener("change", (event) => {
          setActiveSet(event.target.value);
        });
      });
    }

    if (addSetBtn) {
      addSetBtn.addEventListener("click", () => {
        const name = promptForSetName(getDefaultSetName());
        if (name === null) return;
        const newSet = createSet(name);
        sets.push(newSet);
        setActiveSet(newSet.id);
      });
    }

    if (renameSetBtn) {
      renameSetBtn.addEventListener("click", () => {
        const active = getActiveSet();
        if (!active) return;
        const name = promptForSetName(active.name || getDefaultSetName());
        if (name === null) return;
        active.name = name;
        saveSets();
        renderSetSelect();
      });
    }

    if (deleteSetBtn) {
      deleteSetBtn.addEventListener("click", () => {
        if (sets.length <= 1) {
          alert("At least one set is required.");
          return;
        }
        const active = getActiveSet();
        if (!active) return;
        const confirmed = window.confirm(`Delete set "${active.name}"? This cannot be undone.`);
        if (!confirmed) return;
        sets = sets.filter((set) => set.id !== active.id);
        activeSetId = sets[0]?.id || "";
        saveSets();
        refreshActiveSetState();
      });
    }

    if (importSetBtn && importInput) {
      importSetBtn.addEventListener("click", () => {
        importInput.value = "";
        importInput.click();
      });
    }

    if (exportSetBtn) {
      exportSetBtn.addEventListener("click", () => {
        exportCurrentSetToTSV();
      });
    }

    if (backupBtn) {
      backupBtn.addEventListener("click", () => {
        exportAllSetsToJSON();
      });
    }

    if (restoreBtn && restoreInput) {
      restoreBtn.addEventListener("click", () => {
        restoreInput.value = "";
        restoreInput.click();
      });
    }

    if (importInput) {
      importInput.addEventListener("change", (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const result = e.target && typeof e.target.result === "string" ? e.target.result : "";
          importTSVContent(result);
        };
        reader.onerror = () => {
          alert("Failed to read the selected file.");
        };
        reader.readAsText(file);
      });
    }

    if (restoreInput) {
      restoreInput.addEventListener("change", (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const result = e.target && typeof e.target.result === "string" ? e.target.result : "";
          importJSONContent(result);
        };
        reader.onerror = () => {
          alert("Failed to read the selected file.");
        };
        reader.readAsText(file);
      });
    }

    playBtn.addEventListener("click", () => { speakSentence(1); setTimeout(() => checkBtn.focus(), 0); });
    checkBtn.addEventListener("click", () => {
      if (checkBtn.dataset.mode === "restart") {
        rebuildQueue();
        answerEl.disabled = false;
        playBtn.disabled = false;
        pickRandomSentence();
        setTimeout(() => playBtn.focus(), 0);
        return;
      }
      if (checkBtn.dataset.mode === "next") {
        pickRandomSentence();
        setTimeout(() => checkBtn.focus(), 0);
        if (currentIndex >= 0) {
          speakSentence(1);
        }
        return;
      }
      checkAnswer();
      setTimeout(() => checkBtn.focus(), 0);
    });

    answerEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        checkBtn.click();
      }
    });
    if (speakingCheckBtn) {
      speakingCheckBtn.addEventListener("click", () => {
        if (speakingCheckBtn.dataset.mode === "restart") {
          rebuildSpeakingQueue();
          pickSpeakingSentence();
          return;
        }
        if (speakingCheckBtn.dataset.mode === "next") {
          pickSpeakingSentence();
          return;
        }
        const item = sentences[speakingIndex];
        if (!item || !speakingReveal) return;
        speakingReveal.style.display = "block";
        speakingReveal.className = "overlay";
        speakingReveal.textContent = item.sentence || "";
        speakingCheckBtn.textContent = "Next";
        speakingCheckBtn.dataset.mode = "next";
        if (speakingCorrectBtn) {
          speakingCorrectBtn.style.display = "inline-flex";
        }
        if (speakingLearnedBtn) {
          speakingLearnedBtn.style.display = "inline-flex";
        }
        if (speakingMonthBtn) {
          speakingMonthBtn.style.display = "inline-flex";
        }
        if (speakingArchivedBtn) {
          speakingArchivedBtn.style.display = "inline-flex";
        }
        speakText(item.sentence || "", 1);
      });
    }
    learnedBtn.addEventListener("click", () => {
      if (sentences.length === 0 || currentIndex < 0) return;
      const learnedIndex = currentIndex;
      const learnedItem = sentences[learnedIndex];
      if (learnedItem) {
        if (learnedItem.monthUntil) {
          delete learnedItem.monthUntil;
        }
        if (learnedItem.correctUntil) {
          delete learnedItem.correctUntil;
        }
        learnedItem.learnedUntil = Date.now() + learnedCooldownMs;
      }
      saveSets();
      remainingIndices = remainingIndices.filter((i) => i !== learnedIndex);
      currentIndex = -1;
      rebuildQueue();
      rebuildSpeakingQueue();
      renderSentenceList();
      renderPracticeSelect();
      renderSpeakingSelect();
      if (currentIndex >= 0) {
        speakSentence(1);
        setTimeout(() => checkBtn.focus(), 0);
      }
    });

    if (monthBtn) {
      monthBtn.addEventListener("click", () => {
        if (sentences.length === 0 || currentIndex < 0) return;
        const monthIndex = currentIndex;
        const monthItem = sentences[monthIndex];
        if (monthItem) {
          if (monthItem.learnedUntil) {
            delete monthItem.learnedUntil;
          }
          if (monthItem.correctUntil) {
            delete monthItem.correctUntil;
          }
          monthItem.monthUntil = Date.now() + monthCooldownMs;
        }
        saveSets();
        remainingIndices = remainingIndices.filter((i) => i !== monthIndex);
        currentIndex = -1;
        rebuildQueue();
        rebuildSpeakingQueue();
        renderSentenceList();
        renderPracticeSelect();
        renderSpeakingSelect();
        if (currentIndex >= 0) {
          speakSentence(1);
          setTimeout(() => checkBtn.focus(), 0);
        }
      });
    }

    if (correctBtn) {
      correctBtn.addEventListener("click", () => {
        if (sentences.length === 0 || currentIndex < 0) return;
        const correctIndex = currentIndex;
        const correctItem = sentences[correctIndex];
        if (correctItem) {
          if (correctItem.learnedUntil) {
            delete correctItem.learnedUntil;
          }
          if (correctItem.monthUntil) {
            delete correctItem.monthUntil;
          }
          correctItem.correctUntil = getNextJstMidnightTimestamp();
        }
        saveSets();
        remainingIndices = remainingIndices.filter((i) => i !== correctIndex);
        currentIndex = -1;
        rebuildQueue();
        rebuildSpeakingQueue();
        renderSentenceList();
        renderPracticeSelect();
        renderSpeakingSelect();
        if (currentIndex >= 0) {
          speakSentence(1);
          setTimeout(() => checkBtn.focus(), 0);
        }
      });
    }

    if (archivedBtn) {
      archivedBtn.addEventListener("click", () => {
        if (sentences.length === 0 || currentIndex < 0) return;
        const archivedIndex = currentIndex;
        const archivedItem = sentences[archivedIndex];
        if (archivedItem) {
          archivedItem.archivedAt = Date.now();
        }
        saveSets();
        remainingIndices = remainingIndices.filter((i) => i !== archivedIndex);
        currentIndex = -1;
        rebuildQueue();
        rebuildSpeakingQueue();
        renderSentenceList();
        renderPracticeSelect();
        renderSpeakingSelect();
        if (currentIndex >= 0) {
          speakSentence(1);
          setTimeout(() => checkBtn.focus(), 0);
        }
      });
    }

    if (speakingLearnedBtn) {
      speakingLearnedBtn.addEventListener("click", () => {
        if (sentences.length === 0 || speakingIndex < 0) return;
        const learnedItem = sentences[speakingIndex];
        if (learnedItem) {
          if (learnedItem.monthUntil) {
            delete learnedItem.monthUntil;
          }
          if (learnedItem.correctUntil) {
            delete learnedItem.correctUntil;
          }
          learnedItem.learnedUntil = Date.now() + learnedCooldownMs;
        }
        saveSets();
        speakingRemainingIndices = speakingRemainingIndices.filter((i) => i !== speakingIndex);
        speakingIndex = -1;
        rebuildQueue();
        rebuildSpeakingQueue();
        renderSentenceList();
        renderPracticeSelect();
        renderSpeakingSelect();
      });
    }

    if (speakingMonthBtn) {
      speakingMonthBtn.addEventListener("click", () => {
        if (sentences.length === 0 || speakingIndex < 0) return;
        const monthItem = sentences[speakingIndex];
        if (monthItem) {
          if (monthItem.learnedUntil) {
            delete monthItem.learnedUntil;
          }
          if (monthItem.correctUntil) {
            delete monthItem.correctUntil;
          }
          monthItem.monthUntil = Date.now() + monthCooldownMs;
        }
        saveSets();
        speakingRemainingIndices = speakingRemainingIndices.filter((i) => i !== speakingIndex);
        speakingIndex = -1;
        rebuildQueue();
        rebuildSpeakingQueue();
        renderSentenceList();
        renderPracticeSelect();
        renderSpeakingSelect();
      });
    }

    if (speakingCorrectBtn) {
      speakingCorrectBtn.addEventListener("click", () => {
        if (sentences.length === 0 || speakingIndex < 0) return;
        const correctItem = sentences[speakingIndex];
        if (correctItem) {
          if (correctItem.learnedUntil) {
            delete correctItem.learnedUntil;
          }
          if (correctItem.monthUntil) {
            delete correctItem.monthUntil;
          }
          correctItem.correctUntil = getNextJstMidnightTimestamp();
        }
        saveSets();
        speakingRemainingIndices = speakingRemainingIndices.filter((i) => i !== speakingIndex);
        speakingIndex = -1;
        rebuildQueue();
        rebuildSpeakingQueue();
        renderSentenceList();
        renderPracticeSelect();
        renderSpeakingSelect();
      });
    }

    if (speakingArchivedBtn) {
      speakingArchivedBtn.addEventListener("click", () => {
        if (sentences.length === 0 || speakingIndex < 0) return;
        const archivedItem = sentences[speakingIndex];
        if (archivedItem) {
          archivedItem.archivedAt = Date.now();
        }
        saveSets();
        speakingRemainingIndices = speakingRemainingIndices.filter((i) => i !== speakingIndex);
        speakingIndex = -1;
        rebuildQueue();
        rebuildSpeakingQueue();
        renderSentenceList();
        renderPracticeSelect();
        renderSpeakingSelect();
      });
    }

    tabBtns.forEach((btn) => {
      btn.addEventListener("click", () => {
        tabBtns.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        const view = btn.dataset.view;
        views.forEach((v) => v.classList.toggle("active", v.id === view));
      });
    });

    if (historySearch) {
      historySearch.addEventListener("input", () => {
        renderHistoryList();
      });
    }

    document.addEventListener("keydown", (event) => {
      const key = event.key.toLowerCase();
      const hasCtrl = event.ctrlKey || event.metaKey;
      const combo = hasCtrl && event.shiftKey;
      const activeView = document.querySelector(".view.active");
      const isSpeaking = activeView && activeView.id === "speaking";
      if (combo && key === "z") {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        if (isSpeaking) {
          speakSpeakingSentence(1);
        } else {
          speakSentenceOnce(1);
        }
      }
      if (combo && key === "s") {
        event.preventDefault();
        if (isSpeaking) {
          speakSpeakingSentence(0.7);
        } else {
          speakSentence(0.7);
        }
      }
      if (combo && key === "c") {
        if (isSpeaking && speakingCheckBtn && speakingCheckBtn.dataset.mode === "next" && !speakingCheckBtn.disabled) {
          event.preventDefault();
          speakingCheckBtn.click();
          return;
        }
        if (isSpeaking && speakingCheckBtn && speakingCheckBtn.dataset.mode === "check" && !speakingCheckBtn.disabled) {
          event.preventDefault();
          speakingCheckBtn.click();
          return;
        }
        if (!isSpeaking && checkBtn.dataset.mode === "next" && !checkBtn.disabled) {
          event.preventDefault();
          checkBtn.click();
          return;
        }
        if (!isSpeaking && checkBtn.dataset.mode === "check" && !checkBtn.disabled) {
          event.preventDefault();
          checkBtn.click();
          return;
        }
        if (isSpeaking && speakingReveal) {
          const text = speakingReveal.textContent.trim();
          if (text) {
            copyToClipboard(text);
            event.preventDefault();
          }
          return;
        }
        if (!isSpeaking && copyRevealToClipboard()) {
          event.preventDefault();
        }
      }
      if (combo && key === "p") {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        if (isSpeaking) {
          speakSpeakingSentence(1);
          setTimeout(() => speakingCheckBtn?.focus(), 0);
        } else if (!playBtn.disabled) {
          speakSentence(1);
          setTimeout(() => checkBtn.focus(), 0);
        }
      }
      if (combo && key === "n") {
        event.preventDefault();
        if (isSpeaking && speakingCheckBtn && speakingCheckBtn.dataset.mode === "next" && !speakingCheckBtn.disabled) {
          speakingCheckBtn.click();
          return;
        }
        if (!isSpeaking && checkBtn.dataset.mode === "next" && !checkBtn.disabled) {
          checkBtn.click();
        }
      }
      if (combo && key === "w") {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        if (isSpeaking && speakingLearnedBtn && speakingLearnedBtn.style.display !== "none" && !speakingLearnedBtn.disabled) {
          speakingLearnedBtn.click();
          return;
        }
        if (!isSpeaking && learnedBtn.style.display !== "none" && !learnedBtn.disabled) {
          learnedBtn.click();
        }
      }
      if (combo && key === "a") {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        if (isSpeaking && speakingArchivedBtn && speakingArchivedBtn.style.display !== "none" && !speakingArchivedBtn.disabled) {
          speakingArchivedBtn.click();
          return;
        }
        if (!isSpeaking && archivedBtn.style.display !== "none" && !archivedBtn.disabled) {
          archivedBtn.click();
        }
      }
      if (combo && key === "m") {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        if (isSpeaking && speakingMonthBtn && speakingMonthBtn.style.display !== "none" && !speakingMonthBtn.disabled) {
          speakingMonthBtn.click();
          return;
        }
        if (!isSpeaking && monthBtn.style.display !== "none" && !monthBtn.disabled) {
          monthBtn.click();
        }
      }
      if (combo && key === "t") {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        if (isSpeaking && speakingCorrectBtn && speakingCorrectBtn.style.display !== "none" && !speakingCorrectBtn.disabled) {
          speakingCorrectBtn.click();
          return;
        }
        if (!isSpeaking && correctBtn.style.display !== "none" && !correctBtn.disabled) {
          correctBtn.click();
        }
      }
    }, true);

    loadSets();
    loadHistory();
    renderAll();
  </script>
</body>
</html>
